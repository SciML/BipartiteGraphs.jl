var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Bipartite-Graphs","page":"API Reference","title":"Bipartite Graphs","text":"","category":"section"},{"location":"api/#Maximal-matching","page":"API Reference","title":"Maximal matching","text":"","category":"section"},{"location":"api/#DiCMOBiGraph","page":"API Reference","title":"DiCMOBiGraph","text":"","category":"section"},{"location":"api/#Condensation-graphs","page":"API Reference","title":"Condensation graphs","text":"","category":"section"},{"location":"api/#BipartiteGraphs.BipartiteEdge","page":"API Reference","title":"BipartiteGraphs.BipartiteEdge","text":"struct BipartiteEdge{I<:Integer} <: Graphs.AbstractEdge{I<:Integer}\n\nThe edge of a BipartiteGraph. Use Graphs.src and Graphs.dst to get the source and destination vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#Graphs.src-Tuple{BipartiteEdge}","page":"API Reference","title":"Graphs.src","text":"src(edge::BipartiteEdge) -> Integer\n\n\nObtain the source vertex of a BipartiteEdge.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.dst-Tuple{BipartiteEdge}","page":"API Reference","title":"Graphs.dst","text":"dst(edge::BipartiteEdge) -> Integer\n\n\nObtain the destination vertex of a BipartiteEdge.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.VertType","page":"API Reference","title":"BipartiteGraphs.VertType","text":"@enum VertTyoe SRC DST\n\nAn enum for the two types of vertices (source and destination) in  a BipartiteGraph.\n\n\n\n\n\n","category":"type"},{"location":"api/#BipartiteGraphs.BipartiteGraph","page":"API Reference","title":"BipartiteGraphs.BipartiteGraph","text":"mutable struct BipartiteGraph{I<:Integer, M} <: Graphs.AbstractGraph{I<:Integer}\n\nA bipartite graph representation between two, possibly distinct, sets of vertices (source and dependencies). Maps source vertices, labelled 1:Nâ‚, to vertices on which they depend (labelled 1:Nâ‚‚).\n\nFields\n\nne\nfadjlist\nbadjlist\nmetadata\n\nExample\n\nusing BipartiteGraphs\n\n# six source vertices\nfadjlist = [[1],[1],[2],[2],[1],[1,2]]\n\n# two vertices they depend on\nbadjlist = [[1,2,5,6],[3,4,6]]\n\nbg = BipartiteGraph(7, fadjlist, badjlist)\n\n\n\n\n\n","category":"type"},{"location":"api/#BipartiteGraphs.invview-Tuple{BipartiteGraph}","page":"API Reference","title":"BipartiteGraphs.invview","text":"invview(\n    g::BipartiteGraph\n) -> BipartiteGraph{I, Nothing} where I<:Integer\n\n\nReturn a BipartiteGraph with the source and destination vertices swapped. Note that the returned graph aliases g. Requires that g is complete.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.complete-Union{Tuple{BipartiteGraph{I}}, Tuple{I}} where I","page":"API Reference","title":"BipartiteGraphs.complete","text":"complete(g::BipartiteGraph{I}) -> BipartiteGraph{I} where I\n\n\nPopulate the backward adjacency list of g, if it is not already stored.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.require_complete-Tuple{BipartiteGraph}","page":"API Reference","title":"BipartiteGraphs.require_complete","text":"require_complete(g::BipartiteGraph) -> Bool\n\n\nUtility function to throw an error if the graph g is not complete.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.empty!-Tuple{BipartiteGraph}","page":"API Reference","title":"Base.empty!","text":"empty!(g::BipartiteGraph) -> BipartiteGraph\n\n\nRemove all edges from the graph, retaining the source and destination vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.ð‘ vertices","page":"API Reference","title":"BipartiteGraphs.ð‘ vertices","text":"ð‘ vertices(g::BipartiteGraph) -> Base.OneTo{Int64}\n\n\nObtain the number of source vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.ð‘‘vertices","page":"API Reference","title":"BipartiteGraphs.ð‘‘vertices","text":"ð‘‘vertices(g::BipartiteGraph) -> Base.OneTo\n\n\nObtain the number of destination vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.has_ð‘ vertex","page":"API Reference","title":"BipartiteGraphs.has_ð‘ vertex","text":"has_ð‘ vertex(g::BipartiteGraph, v::Integer) -> Any\n\n\nCheck if v is a source vertex of g.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.has_ð‘‘vertex","page":"API Reference","title":"BipartiteGraphs.has_ð‘‘vertex","text":"has_ð‘‘vertex(g::BipartiteGraph, v::Integer) -> Any\n\n\nCheck if v is a destination vertex of g.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.ð‘ neighbors","page":"API Reference","title":"BipartiteGraphs.ð‘ neighbors","text":"ð‘ neighbors(\n    g::BipartiteGraph,\n    i::Integer\n) -> Vector{I} where I<:Integer\nð‘ neighbors(\n    g::BipartiteGraph,\n    i::Integer,\n    with_metadata::Val{M}\n) -> Any\n\n\nObtain the neighbors of source vertex i in graph g.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.ð‘‘neighbors","page":"API Reference","title":"BipartiteGraphs.ð‘‘neighbors","text":"ð‘‘neighbors(g::BipartiteGraph, j::Integer) -> Vector{Int64}\nð‘‘neighbors(\n    g::BipartiteGraph,\n    j::Integer,\n    with_metadata::Val{M}\n) -> Union{Base.Iterators.Zip{Is} where Is<:Tuple{Vector{Int64}, Base.Generator{Vector{Int64}, F} where F<:(BipartiteGraphs.var\"#10#11\"{BipartiteGraph{I, M}, <:Integer} where {I<:Integer, M})}, Vector{Int64}}\n\n\nObtain the neighbors of destination vertex i in graph g.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.ð‘ edges","page":"API Reference","title":"BipartiteGraphs.ð‘ edges","text":"ð‘ edges(\n    g::BipartiteGraph\n) -> BipartiteGraphs.BipartiteEdgeIter{SRC, G} where G<:BipartiteGraph\n\n\nIterate over all edges in the graph, ordered by source vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.ð‘‘edges","page":"API Reference","title":"BipartiteGraphs.ð‘‘edges","text":"ð‘‘edges(\n    g::BipartiteGraph\n) -> BipartiteGraphs.BipartiteEdgeIter{DST, G} where G<:BipartiteGraph\n\n\nIterate over all edges in the graph, ordered by destination vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.edges-Tuple{BipartiteGraph}","page":"API Reference","title":"Graphs.edges","text":"edges(\n    g::BipartiteGraph\n) -> BipartiteGraphs.BipartiteEdgeIter{SRC, G} where G<:BipartiteGraph\n\n\nIterate over all edges in the graph, ordered by source vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.nsrcs","page":"API Reference","title":"BipartiteGraphs.nsrcs","text":"nsrcs(g::BipartiteGraph) -> Int64\n\n\nGet the number of source vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.ndsts","page":"API Reference","title":"BipartiteGraphs.ndsts","text":"ndsts(g::BipartiteGraph) -> Any\n\n\nGet the number of destination vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.nv-Tuple{BipartiteGraph}","page":"API Reference","title":"Graphs.nv","text":"nv(g::BipartiteGraph) -> Any\n\n\nGet the total number of vertices (source and destination) in the graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.vertices-Tuple{BipartiteGraph}","page":"API Reference","title":"Graphs.vertices","text":"vertices(\n    g::BipartiteGraph\n) -> Tuple{Base.OneTo{Int64}, Base.OneTo}\n\n\nObtain both source and destination vertices of the graph as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.add_edge!-Tuple{BipartiteGraph, Integer, Integer}","page":"API Reference","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(g::BipartiteGraph, i::Integer, j::Integer) -> Bool\nadd_edge!(\n    g::BipartiteGraph,\n    i::Integer,\n    j::Integer,\n    md\n) -> Bool\n\n\nAdd an edge from source i to destination j in graph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.add_edge!-Tuple{BipartiteGraph, BipartiteEdge}","page":"API Reference","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(g::BipartiteGraph, edge::BipartiteEdge) -> Bool\nadd_edge!(\n    g::BipartiteGraph,\n    edge::BipartiteEdge,\n    md\n) -> Bool\n\n\nAdd edge to graph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.rem_edge!-Tuple{BipartiteGraph, Integer, Integer}","page":"API Reference","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(g::BipartiteGraph, i::Integer, j::Integer) -> Bool\n\n\nRemove the edge from source i to destination j in graph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.rem_edge!-Tuple{BipartiteGraph, BipartiteEdge}","page":"API Reference","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(g::BipartiteGraph, edge::BipartiteEdge) -> Bool\n\n\nFemove edge from graph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{T}, Tuple{BipartiteGraph{T}, BipartiteGraphs.VertType}} where T","page":"API Reference","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(\n    g::BipartiteGraph{T},\n    type::BipartiteGraphs.VertType\n) -> Any\n\n\nAdd a vertex of type type to graph g.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.set_neighbors!","page":"API Reference","title":"BipartiteGraphs.set_neighbors!","text":"set_neighbors!(\n    g::BipartiteGraph,\n    i::Integer,\n    new_neighbors\n) -> Any\n\n\nIn graph g, set the neighbors of source vertex i to new_neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.delete_srcs!","page":"API Reference","title":"BipartiteGraphs.delete_srcs!","text":"delete_srcs!(\n    g::BipartiteGraph{I},\n    srcs;\n    rm_verts\n) -> BipartiteGraph{I} where I\n\n\nIn graph g, remove all edges incident on source vertices in srcs. If rm_verts is true, also remove the vertices from the graph. Note that this will cause renumbering of source vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.delete_dsts!","page":"API Reference","title":"BipartiteGraphs.delete_dsts!","text":"delete_dsts!(\n    g::BipartiteGraph,\n    srcs;\n    rm_verts\n) -> BipartiteGraph{I, Nothing} where I<:Integer\n\n\nIn graph g, remove all edges incident on destination vertices in srcs. If rm_verts is true, also remove the vertices from the graph. Note that this will cause renumbering of destination vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.LinAlg.incidence_matrix-Tuple{BipartiteGraph, Any}","page":"API Reference","title":"Graphs.LinAlg.incidence_matrix","text":"incidence_matrix(\n    g::BipartiteGraph\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\nincidence_matrix(\n    g::BipartiteGraph,\n    val\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv\n\n\nObtain the incidence matrix for the BipartiteGraph g. val indicates the value to be used in non-zero entries of the returned sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.maximal_matching","page":"API Reference","title":"BipartiteGraphs.maximal_matching","text":"maximal_matching(g::BipartiteGraph, [srcfilter], [dstfilter])\n\nFor a bipartite graph g, construct a maximal matching of destination to source vertices, subject to the constraint that vertices for which srcfilter or dstfilter, return false may not be matched.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.construct_augmenting_path!","page":"API Reference","title":"BipartiteGraphs.construct_augmenting_path!","text":"construct_augmenting_path!(m::Matching, g::BipartiteGraph, vsrc, dstfilter, vcolor=falses(ndsts(g)), ecolor=nothing) -> path_found::Bool\n\nTry to construct an augmenting path in matching and if such a path is found, update the matching accordingly.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteGraphs.Matching","page":"API Reference","title":"BipartiteGraphs.Matching","text":"A matching between two sets of vertices in a bipartite graph. Maps destination vertices to their matched source vertices. U denotes the type that unmatched variables can take. Typically, this will be Unassigned but other types can be used for more complicated matchings.\n\n\n\n\n\n","category":"type"},{"location":"api/#BipartiteGraphs.Unassigned","page":"API Reference","title":"BipartiteGraphs.Unassigned","text":"A sentinel type representing an unassigned vertex in a matching.\n\n\n\n\n\n","category":"type"},{"location":"api/#BipartiteGraphs.unassigned","page":"API Reference","title":"BipartiteGraphs.unassigned","text":"A singleton instance representing unassigned vertices.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Base.setindex!-Union{Tuple{U}, Tuple{Matching{U}, Union{Integer, U}, Integer}} where U","page":"API Reference","title":"Base.setindex!","text":"setindex!(\n    m::Matching{U},\n    v::Union{Integer, U} where U,\n    i::Integer\n) -> Union{Integer, U} where U\n\n\nUpdate i to match to v in matching m. Also updates the inverse matching, if present.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{Matching, Any}","page":"API Reference","title":"Base.push!","text":"push!(m::Matching, v) -> Any\n\n\nAppend an element to the source vertices of the matching m, and match it to v.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.complete-Union{Tuple{U}, Tuple{Matching{U}, Any}} where U","page":"API Reference","title":"BipartiteGraphs.complete","text":"complete(m::Matching{U}) -> Matching\ncomplete(m::Matching{U}, N) -> Matching\n\n\nPopulate the inverse matching if it is not already computed. The optional parameter N specifies the size of the inverse matching vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.require_complete-Tuple{Matching}","page":"API Reference","title":"BipartiteGraphs.require_complete","text":"require_complete(m::Matching) -> Bool\n\n\nThrow an error if the matching does not have the inverse matching computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.invview-Union{Tuple{Matching{U, V}}, Tuple{V}, Tuple{U}} where {U, V}","page":"API Reference","title":"BipartiteGraphs.invview","text":"invview(m::Matching{U, V}) -> Matching\n\n\nReturn a view of the matching with the forward and inverse matchings swapped. Requires that the matching is complete.\n\n\n\n\n\ninvview(\n    g::DiCMOBiGraph{Transposed, I} where I\n) -> DiCMOBiGraph{_A, I, G} where {_A, I<:Integer, G<:BipartiteGraph{I, Nothing}}\n\n\nReturn a DiCMOBiGraph with the source and destination vertices swapped. The returned graph aliases g.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.DiCMOBiGraph","page":"API Reference","title":"BipartiteGraphs.DiCMOBiGraph","text":"struct DiCMOBiGraph\n\nThis data structure implements a \"directed, contracted, matching-oriented\" view of an original (undirected) bipartite graph. It has two modes, depending on the Transposed flag, which switches the direction of the induced matching.\n\nEssentially the graph adapter performs two largely orthogonal functions [Transposed == true differences are indicated in square brackets]:\n\nIt pairs an undirected bipartite graph with a matching of the destination vertex.\nThis matching is used to induce an orientation on the otherwise undirected graph: Matched edges pass from destination to source [source to destination], all other edges pass in the opposite direction.\nIt exposes the graph view obtained by contracting the destination [source] vertices along the matched edges.\n\nThe result of this operation is an induced, directed graph on the source [destination] vertices. The resulting graph has a few desirable properties. In particular, this graph is acyclic if and only if the induced directed graph on the original bipartite graph is acyclic.\n\nHypergraph interpretation\n\nConsider the bipartite graph B as the incidence graph of some hypergraph H. Note that a matching M on B in the above sense is equivalent to determining an (1,n)-orientation on the hypergraph (i.e. each directed hyperedge has exactly one head, but any arbitrary number of tails). In this setting, this is simply the graph formed by expanding each directed hyperedge into n ordinary edges between the same vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#BipartiteGraphs.DiCMOBiGraph-Union{Tuple{BipartiteGraph}, Tuple{Transposed}} where Transposed","page":"API Reference","title":"BipartiteGraphs.DiCMOBiGraph","text":"Construct a DiCMOBiGraph from a bipartite graph with an empty matching.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.DiCMOBiGraph-Union{Tuple{M}, Tuple{Transposed}, Tuple{BipartiteGraph, M}} where {Transposed, M}","page":"API Reference","title":"BipartiteGraphs.DiCMOBiGraph","text":"Construct a DiCMOBiGraph from a bipartite graph and a matching.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.invview-Union{Tuple{DiCMOBiGraph{Transposed, I} where I}, Tuple{Transposed}} where Transposed","page":"API Reference","title":"BipartiteGraphs.invview","text":"invview(m::Matching{U, V}) -> Matching\n\n\nReturn a view of the matching with the forward and inverse matchings swapped. Requires that the matching is complete.\n\n\n\n\n\ninvview(\n    g::DiCMOBiGraph{Transposed, I} where I\n) -> DiCMOBiGraph{_A, I, G} where {_A, I<:Integer, G<:BipartiteGraph{I, Nothing}}\n\n\nReturn a DiCMOBiGraph with the source and destination vertices swapped. The returned graph aliases g.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.AbstractCondensationGraph","page":"API Reference","title":"BipartiteGraphs.AbstractCondensationGraph","text":"Abstract base type for condensation graph representations.\n\n    (::Type{<:AbstractCondensationGraph})(g, sccs::Vector{Vector{Int}})\n\nConstruct an AbstractCondensationGraph from a graph and strongly connected components.\n\n\n\n\n\n","category":"type"},{"location":"api/#Graphs.nv-Tuple{BipartiteGraphs.AbstractCondensationGraph}","page":"API Reference","title":"Graphs.nv","text":"nv(icg::BipartiteGraphs.AbstractCondensationGraph) -> Any\n\n\nGet the number of vertices (strongly connected components) in the condensation graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#BipartiteGraphs.InducedCondensationGraph","page":"API Reference","title":"BipartiteGraphs.InducedCondensationGraph","text":"struct InducedCondensationGraph{G<:BipartiteGraph} <: BipartiteGraphs.AbstractCondensationGraph\n\nFor some bipartite-graph and a topologicall sorted list of connected components, represents the condensation DAG of the digraph formed by the orientation. I.e. this is a DAG of connected components formed by the destination vertices of some underlying bipartite graph. N.B.: This graph does not store explicit neighbor relations of the sccs. Therefor, the edge multiplicity is derived from the underlying bipartite graph, i.e. this graph is not strict.\n\n\n\n\n\n","category":"type"},{"location":"api/#BipartiteGraphs.MatchedCondensationGraph","page":"API Reference","title":"BipartiteGraphs.MatchedCondensationGraph","text":"struct MatchedCondensationGraph{G<:DiCMOBiGraph} <: BipartiteGraphs.AbstractCondensationGraph\n\nFor some bipartite-graph and an orientation induced on its destination contraction, records the condensation DAG of the digraph formed by the orientation. I.e. this is a DAG of connected components formed by the destination vertices of some underlying bipartite graph. N.B.: This graph does not store explicit neighbor relations of the sccs. Therefor, the edge multiplicity is derived from the underlying bipartite graph, i.e. this graph is not strict.\n\n\n\n\n\n","category":"type"},{"location":"#BipartiteGraphs.jl","page":"Home","title":"BipartiteGraphs.jl","text":"This package provides a litany of types and utilities for working with bipartite graphs.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install BipartiteGraphs.jl, use the Julia package manager:\n\nusing Pkg\nPkg.add(\"BipartiteGraphs\")","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"section"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"section"}]
}
